= Groovy port motivation =
Groovy version of chromattic framework have 2 motivations :
* Because Chromattic use Annotation processing, and parse Java at the compile time. It's not possible to apply the same ast transformation in Groovy as Java.
* The dynamic typing of groovy make possible a better integration according to the groovy's culture.

= AST Transformation =
Thanks to AST Transformation, it was possible to transform the AST to adapt the metamodel at the compile time without developers interventions.
In fact, through the AST transformation it's possible to adapt groovy models based on a simple class with properties annoted by the chromattic annotations.
The following operations was made at the compile time to have a well formed model.
* Create or Modify getter and setter to move annotations from fields to getter and/or setter.
* Remove annotations from fields.
* Add a Field "chromatticInvoker" of ##type org.chromattic.spi.instrument.MethodHandler## (The same as the java version).
* Create getter for the field chromatticInvoker (used by the instrumentor to delegate the call to chromattic engine).
* Create or modify the default constructor to a protected accessibility.
* Create an initializer constructor for the field chromatticInvoker.
* Do implements the GroovyInterceptable interface by the class.
* Override the invokeMethod(String methodName, Object parameters) method (Delegate at the MOP level to the chromatticInvoker instance)
* Override the getPerperty(String propertyName) and setProperty(String propertyName, Object propertyValue)

A simple input source file : (((
{{code language=GROOVY href="org/chromattic/docs/reference/groovy/Page.groovy"}}{{/code}})))

The output source code after the AST Transformation : (((
{{code language=GROOVY href="org/chromattic/docs/reference/groovy/CompiledPage.groovy"}}{{/code}})))

= Instrumentation =
The groovy port of chromattic own a proper instrumentor : ##org.chromattic.groovy.instrument.GroovyInstrumentor## which allow to get the method handler of a given proxy instance (in groovy, the proxy is the model instance).
{{example title="The GroovyInstrumentor class"}}
{{java}}
{@javadoc org.chromattic.groovy.instrument.GroovyInstrumentor}
{@include org.chromattic.groovy.instrument.GroovyInstrumentor}
{{/java}}{{/example}}

= Instanciation =
The instanciation was made by ##org.chromattic.groovy.instrument.GroovyProxyType<O>## class. This factory use the initializer constructor to initialize the chromatticInvoker field with the chromattic method handler (generated at the compile time).
{{example title="The GroovyProxyType class"}}
{{java}}
{@javadoc org.chromattic.groovy.instrument.GroovyProxyType}
{@include org.chromattic.groovy.instrument.GroovyProxyType}
{{/java}}{{/example}}

= Chromattic core delegation =
All call was redirected to a single class : ##org.chromattic.groovy.ChromatticGroovyInvocation## which forward the MOP call to the MethodHandler.
{{example title="The ChromatticGroovyInvocation class"}}
{{java}}
{@javadoc org.chromattic.groovy.ChromatticGroovyInvocation}
{@include org.chromattic.groovy.ChromatticGroovyInvocation}
{{/java}}{{/example}}