- OneToMany with reference : move relationship
- OneToOne with several named children
- Make configurable the removal of a node with respect to the references
- Map hierarchy using Map<String, Foo>, Map<String, ?>
- transient / removed method invocations
- more control over session with @Save annotation ?
- protected methods instead of public
- boolean properties with isXXX()
- Map<String, ?> property mapping like Map<String, Integer> or Map<String, String>
- spi for classloader integration
- create relationship with non persistent contexts
- use has changes to perform caching!!!!!!!!
- detect mapped conflicts with collection, like if we add to a collection a node named by the another mapped by property then refuse it
- mix of 2 sessions
- consider not resolvable generics, would help to make more flexible
- test reference iterator remove
- test reference iterator concurrent modification exceptions
- pluggable simple types : enums, annotated classes
- ordered children support with list
- sorted map support for ordered children ?
- name mapping, for instance foo -> exo:foo
- improve @OneToMany Map<String, ?> remove() method to remove by getting a child and not the default iterator operation
- type coercion unit testing
- undefined properties unit test
- residual properties unit test


*** Patrice
- mapping of @Property for InputStream
- mapping of @Property List<T> 
- @Workspace to inject the name of the workspace where the Node was loaded
- @Property(name="foo", default="bar") : Needed to initialize a property with a default value (in case it was no done in nodetype def)
- alternatively : @Initialize public <T> T someCustomMethod(T objectToInitialize) {// let me implement whatever logic I want to initialize my object with default values}
- <T> T Session.loadOrCreate(Class<T> clazz, String absPath) // tries to load an object from location "absPath" and initializes a new one if it does not exist (the parent location must exist)
-   @Property(name="foo") public abstract boolean getFoo(); will fail when you call it if the value in JCR is NULL


*** crazy ideas

(patrice)
- @FindByPath to get a desendant from its relPath
- @FindByName to get a child by name
- Provide ready to use annotated classes/interfaces for buitin jcr types like nt:file et nt:resource
- enable write on @Name and @Path : this would move the node when persisting!
julien: I would rather do it as a collection move i.e
if you do
a.addChild(b);
c.addChild(b);
then the second operation would do a move to detach the node from a and attach it to c
