= The ##@PrimaryType## annotation =

The ##org.chromattic.api.annotations.PrimaryType## annotation creates a unique correspondance between
a Java class and a JCR primary node type. The mapping between an annotated class and the primary type must be unique for
the JCR node type, therefore it is not possible to have the same node type mapped to more than one class inside the same
Chromattic application.

We use a modified version of the ##Page## object that contains now more properties to illustrate
this chapter.

= Mapping properties =

== Property type mapping ==

JCR defines the following set of property types:

* The ##STRING## type
* The ##BOOLEAN## type
* The ##LONG## type
* The ##DOUBLE## type
* The ##DATE## type
* The ##NAME## type
* The ##BINARY## type
* The ##PATH## type
* The ##REFERENCE## type

Any of those types except the ##REFERENCE## type can be mapped to an object property.

##REFERENCE## types can be used, however this type is not mapped to a specific Java type, instead
Chromattic supports it thanks to the concept of relationship that will be explained in the [[#reference_relationship_section]].

=== Generic data types ===

JCR provides two types to map generic data types:

* The JCR ##STRING## type is mapped to the Java ##java.lang.String## type.
* The JCR ##BINARY## type is mapped to the Java ##byte[]## type or the  ##java.io.InputStream## type.

The string type is pretty straightforward to use, you simplet get or set the string that is mapped to the JCR property.


The binary type can be used in two different manners, the first one maps the ##BINARY## type to a byte array. This mapping
style is similar to the string mapping except that a byte array is not immutable. The client has the opportunity to alter the
array as Chromattic cannot prevent it to be modified. This mapping style is very straightforward too but has the inconvenient
to load the whole stream into memory which is not always desirable for very large streams.

The other manner maps the ##BINARY## type to an ##java.io.InputStream##. This behavior is actually the JCR native behavior and
Chromattic provides it as well, as it has the benefit to use an input stream to read and write binary data which is efficient
for large binary content. This approach does not force to hold all the data in memory, unlike the byte array approach. However
it requires a little extra work from the developer to use the input stream carefully.

To read the data, the property getter returns an input stream that provides access to the binary data. The stream should be
used as any other kind of input stream: consume data until the stream is empty and then close the stream in a finally block.
The stream must be used corrected, otherwise the entire content could be loaded in memory and that would defeat the
purpose of the stream based approach.

To write data, the property setter must be called with an input stream that is used to consume all
the data available. It means that on the return of the setter, the input stream shouldn't be used anymore for reading
data as Chromattic will close the stream. Again here, the stream must be used carefully.

=== Primitive types ===

The types ##BOOLEAN##, ##LONG## and ##DOUBLE## are mapped to Java primitive types:

* The JCR ##BOOLEAN## type is mapped to the Java ##boolean## type
* The JCR ##LONG## type is mapped to either the Java ##int## or ##long## type
* The JCR ##DOUBLE## type is mapped to either the Java ##double## or ##float## type

For each of those types, there is the choice between either the Java primitive type or the Java wrapper type.

=== Temporal type ===

JCR defines a ##DATE## type that represents a date. Chromattic provides three different mappings for this type:

1. Java date objects
11. ##java.util.Calendar## mapping, the same type exposed by the native JCR API.
11. ##java.util.Date## mapping
1. ##java.lang.Long## or ##long## mapping exposing the value returned by ##Calendar#getTimeMillis()##

Date objects objects are mutable by nature and Chromattic clones them when it is necessary to preserve the data.
A date object returned by Chromattic can be modified without changing mapped JCR value, likewise a property update will
read the value once and copy it.

== Property mapping ==

The ##org.chromattic.api.annotations.Property## annotation binds an object to a node property. Our
##Page## shows several examples of property mapping using the ##@Property## annotation.
This annotation has a mandatory ##name## parameter to provide the name of the corresponding JCR
property. 

{{java}}
{@include org.chromattic.api.annotations.Property}
{{/java}}

The ##Property## annotation can either annotate the getter or annotate the setter but it should be used
only once with read/write accessible properties.

== Single valued property mapping ==

The most common mapping style between a single valued class and a node property. The object property must
provide at least a setter method or a getter method, probably both in most use cases, those methods must
use the same java property type.

A property getter method returns the JCR property value. If the property does not exist, the null value is returned
when the java property type is not a primitive type. Sometimes it can happen that the JCR property does not exist
but this property is mapped to a primitive type. When the situation occurs Chromattic throws a ##NullPointerException##,
that behavior is similar to what happens when a null value is unboxed to its corresponding primitive type.

A property setter method updates the JCR property value when it is invoked. For non primitive type it is possible to
delete the property by providing a null argument.

{{java}}
{@javadoc org.chromattic.docs.reference.primarytypemapping.Page#getTitle()}
{@include org.chromattic.docs.reference.primarytypemapping.Page#getTitle()} // <1> The title property is mapped the ##STRING## type

{@javadoc org.chromattic.docs.reference.primarytypemapping.Page#setTitle(java.lang.String)}
{@include org.chromattic.docs.reference.primarytypemapping.Page#setTitle(java.lang.String)}

{@javadoc org.chromattic.docs.reference.primarytypemapping.Page#getLastModifiedDate()}
{@include org.chromattic.docs.reference.primarytypemapping.Page#getLastModifiedDate()} // <2> the last modified date property is mapped to the ##DATE## type

{@javadoc org.chromattic.docs.reference.primarytypemapping.Page#setLastModifiedDate(java.util.Date)}
{@include org.chromattic.docs.reference.primarytypemapping.Page#setLastModifiedDate(java.util.Date)}
{{/java}}

The corresponding JCR node defines a title property and lastModifiedDate property:

{{xml indent=2}}
<propertyDefinition name="title" requiredType="STRING" autoCreated="false" mandatory="false" onParentVersion="COPY"
protected="false" multiple="false">
  <valueConstraints />
</propertyDefinition>
<propertyDefinition name="lastmodifieddate" requiredType="DATE" autoCreated="false" mandatory="false" onParentVersion="COPY"
protected="false" multiple="false">
  <valueConstraints />
</propertyDefinition>
{{/xml}}

== Multi valued property mapping ==

JCR naturally provide support for multi valued properties, so does Chromattic. Chromattic gives you the choice
to use either an array or a ##java.util.List## to access the data. A primitive array can be used when
the type is a primitive type.

{{java}}
{@javadoc org.chromattic.docs.reference.primarytypemapping.Page#getTags()}
{@include org.chromattic.docs.reference.primarytypemapping.Page#getTags()} // <> the tags property is mapped to a multi valued ##STRING## type
{{/java}}

The corresponding JCR node defines a tags properties:

{{xml indent=2}}
<propertyDefinition name="title" requiredType="STRING" autoCreated="false" mandatory="false" onParentVersion="COPY"
protected="false" multiple="true">
  <valueConstraints />
</propertyDefinition>
{{/xml}}

When a list of values is returned by a getter method, any modification to this list is only visible to this list and
does not affect the JCR property values. When the JCR property does not exist, a null value is returned to the caller.

To update the values of a JCR property, the property setter has to be invoked. The list of values is read once and
copied to the corresponding JCR property. If the list is null, it simply delete the property.

== Mixing multi value and single value styles ==

It can be convenient to map a single valued property to a multi valued property. For instance a multi valued JCR
 property exposed as a single valued property provides access to the first value of the values.

|=                 |=JCR single valued|=JCR multi valued
|Java single valued| trivial mapping  |access the first element
|Java multi valued | a list of size 1 |trivial mapping

The same multi valued JCR property can be exposed both as a single and multi valued property. The multi valued property
gives access to the complete list of values and the single valued property is useful when the first value needs to be
accessed.

= Mapping parent child relationships =

Chromattic makes the usage of the JCR node hierarchy very natural thanks to relationship mapping. Chromattic defines
two mapping styles one-to-many/many-to-one and one-to-one mapping. The one-to-one mapping is useful for accessing
the particular child of a node, the one-to-many-many-to-one mapping is useful for accessing residual node definitions
defined by a wildcard (*) name.

== One-to-many/many-to-one hierarchical relationship mapping {{anchor id=hierarchical_onetomany_section/}} ==

The usage of Java generics combined with different types of collection provides a flexible mapping. Java generics allows
collection filtering based on the type of the collection, it becomes handy when you need to access the a subset of the
child nodes filtered with a specific node type (make a chapter on genericity).

Chromattic provides access to the children of node with a Java collection. A bean annotates a collection valued getter
with the ##@OneToMany## annotation.

{{java}}
{@javadoc org.chromattic.docs.reference.primarytypemapping.Page#getChildren()}
{@include org.chromattic.docs.reference.primarytypemapping.Page#getChildren()}
{{/java}}

The getter method never returns a null value as a node always provides a set of children even if this set is empty. Unlike for
multi valued property collection, any modification to this collection will be reflected directly by the underlying JCR node
children and vice versa:

* The ##add(Page page)## adds a page
* The ##remove(Object o)## removes a page
* The ##clear()## removes all the page children
* The ##iterator()## returns an ##iterator## that can be used to remove any child

The other collection methods of the collection class are read methods that won't modify the children and provides various ways
to deal with the children.

The ##Page## object also provides to its parent with a property annotated with the ##ManyToOne## annotation. The getter
 method returns the object associated to the parent node.

{{java}}
{@javadoc org.chromattic.docs.reference.primarytypemapping.Page#getParent()}
{@include org.chromattic.docs.reference.primarytypemapping.Page#getParent()}

{@javadoc org.chromattic.docs.reference.primarytypemapping.Page#setParent(org.chromattic.docs.reference.primarytypemapping.Page)}
{@include org.chromattic.docs.reference.primarytypemapping.Page#setParent(org.chromattic.docs.reference.primarytypemapping.Page)}
{{/java}}

 A null value can be obtained in two particular situations:

1. When an object is associated to the root node, indeed the root node is the only node without a parent
1. When an object has a parent of a JCR node type that is not mapped to the Chromattic object returned the getter

It is legal for an object to have several parent accessors when the corresponding JCR node type can have different
parent node types. When the various parent types share a common parent class, this class can be used to have a single
 accessor instead. Ultimately it is possible to use the ##java.lang.Object## type that is implicitely mapped to the
##nt:base## node typen, the ##nt:base## node type is the super type of all JCR node types. (todo: make a section about that somewhere else to clarify)

=== Adding a child node ===

There are several ways for adding a child and we are going to examine two of them in this section.

The first way to add a child is to use the collection returned by the parent object. As said earlier, any modification to the
collection is directly reflected into the corresponding JCR node.

{{java}}
{@include org.chromattic.docs.reference.primarytypemapping.PrimaryTypeMappingTestCase#testChildrenCollection() {1}}
{{/java}}

The second way is to use to add a child is to use the parent setter.

{{java}}
{@include org.chromattic.docs.reference.primarytypemapping.PrimaryTypeMappingTestCase#testParent() {1}}
{{/java}}

Setting the parent to the child has the same effect than adding the child to the collection. Indeed we can notice in both
examples that the when one style is used, we get the same result: the parent getter returns the parent object and the children
collection contains the child.

In both case, Chromattic will use the name set on the child before it is inserted in its parent. The session ##create## method
call takes as second argument the name of the future child. This name is stored temporarily on the create child and is used
when the node is effectively inserted.

=== Destroying a node ===

We have explained two ways for adding a child to a parent, we will now see that we can use the same methods to destroy a node
and its relationship to its parent (indeed in JCR, the only node with no parent is the root node).

When a child is removed from its parent collection, it is removed.

{{java}}
{@include org.chromattic.docs.reference.primarytypemapping.PrimaryTypeMappingTestCase#testChildrenCollection() {2}}
{{/java}}

Setting the parent of a Chromattic object to null forces Chromattic to remove the object and the associated node.

{{java}}
{@include org.chromattic.docs.reference.primarytypemapping.PrimaryTypeMappingTestCase#testParent() {2}}
{{/java}}

=== Collection types ===

In our example we have examined the ##ManyToOne## side of the relationship based on a ##java.util.Collection## interface.
Two other type of mapping are available ##java.util.List## and ##java.util.Map##, let's study what would become our example
with such mappings.

==== ##java.util.List## mapping ====

The list mapping must be only used when the corresponding node type has defined its children to be ordered. The list interface
adds the notion of order to the collection interface, and using the order oriented method on the list will affect the
order of the children.

{{example title="Moving a child from the first position to the last position"}}
{{java}}
children.add(children.get(0));
{{/java}}
{{/example}}

==== ##java.util.Map## mapping ====

The map interface adds the notion of key which is very useful when the children needs to be accessed by their key. Previously
we have seen that when the child is created from the session, its name has to be specifed. When the map interface is used,
this is not necessary anymore, as the child name is specified when it is inserted with the ##put(String key, Page value)## operation.

{{example title="Child insertion"}}
{{java}}
Page page = session.create(Page.class);
children.put("foo", page);
{{/java}}
{{/example}}

{{example title="Obtaining a particular child"}}
{{java}}
Page foo = children.get("foo");
{{/java}}
{{/example}}

{{example title="Child removal"}}
{{java}}
children.remove("foo");
{{/java}}
{{/example}}

== One-to-one hierarchical relationship mapping ==

todo

= Mapping reference relationship {{anchor id=reference_relationship_section/}} =

The hierarchical tree structure supported by JCR is the default way to organize data. JCR provides a reference mechanism
for relationship between nodes, a node has a pointer to target node via a property. The relationship is based on two specific
property types:

* The ##REFERENCE## property type references a target node using its UUID.
* The ##PATH## property type references a target node using its path.

The single kind of relationship supported by reference is one-to-many/many-to-one: a node references a target node and
a node can be the target of multiple nodes. 

{{note}}Technically it should be possible to support many-to-many relationship using a multivalued reference property.
This feature could be implemented in the future.{{/note}}

== One-to-many/many-to-one reference relationship mapping == 

Mapping single valued reference properties to Chromattic relationship relationship relies on Java collections, in a similar
 manner hierarchical [[one-to-many/many-to-one relationship>>#hierarchical_onetomany_section]] does.



