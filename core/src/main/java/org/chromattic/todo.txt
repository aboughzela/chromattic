- detyped embedded access from session : <E> E session.getEmbedded(Object o, Class<E> embeddedClass)
- prefix the queries with the root path of the chromattic builder
- unwrap unit test : for now it's a CC / it should somehow test and throw another exception
- rework the encode/decode name : several stuff + allow object name decoder to return null and skip the child ?
- OneToMany with reference : move relationship
- OneToOne with several named children
- Make configurable the removal of a node with respect to the references
- transient / removed method invocations
- more control over session with @Save annotation ?
- Map<String, ?> property mapping like Map<String, Integer> or Map<String, String>
- spi for classloader integration
- create relationship with non persistent contexts
- detect mapped conflicts with collection, like if we add to a collection a node named by the another mapped by property then refuse it
- detect mix of 2 sessions
- test reference iterator remove
- test reference iterator concurrent modification exceptions
- pluggable simple types : annotated classes
- name mapping, for instance foo -> exo:foo
- type coercion unit testing
- undefined properties unit test for lists
- residual properties unit test for lists
- check underlying property type in relationships
- test for corrupted relationship
- clarify semantic of class importance in one to many map mapping : I.E do we expect class cast or non existence ???
- Map iterators on relationship for maximum efficiency and allow skip
- tester que les node type résiduels ont la bonne property type

- create nodetypes.xml from the mappings with an annotation processor

- a cache invalidation framework based on transforming node to object id + class

*** Patrice
- @Property(name="foo", default="bar") : Needed to initialize a property with a default value (in case it was no done in nodetype def)
- alternatively : @Initialize public <T> T someCustomMethod(T objectToInitialize) {// let me implement whatever logic I want to initialize my object with default values}
- <T> T Session.loadOrCreate(Class<T> clazz, String absPath) // tries to load an object from location "absPath" and initializes a new one if it does not exist (the parent location must exist)

*** crazy ideas

(patrice)
- @FindByPath to get a desendant from its relPath
- @FindByName to get a child by name
- enable write on @Name and @Path : this would move the node when persisting!
julien: I would rather do it as a collection move i.e
if you do
a.addChild(b);
c.addChild(b);
then the second operation would do a move to detach the node from a and attach it to c
